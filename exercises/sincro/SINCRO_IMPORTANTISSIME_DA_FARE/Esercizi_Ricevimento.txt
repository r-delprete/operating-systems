1 - RECRUITMENT
Nella sala recruitment di una grande azienda informatica, durante una sessione di interview possono prendere posto al piu' N candidati,
mentre i restanti candidati prenderanno parte alla sessione di interview successiva.
Ogni candidato che ha trovato posto sara' chiamato al tavolo delle interview.
L'addetto alle risorse umane attende fino che e' disponibile un candidato. 
Terminata l'intervista II candidato lascia il tavolo e la sala facendo posto al prossimo candidato.
Le sessioni di interview terminano quando non ci sono piu' candidati in attesa. Proporre una soluzione e 
discutere eventuali problemi di deadlock.

Integer: In_attesa = 0
Semaforo Binario: Tavolo = 0
Semaforo Binario: Interview_finita = 0
Semaforo Contatore: Candidato = 0
Semaforo Contatore: posto_disponibile = 0;
Mutex CS_Conto = 1

Main () {

  crea_processo(Addetto)

  // M >>> N
  for i = 0 to M:
    crea_processo(Candidato)
    
  // Aspetta tutti
  
}

|       |
|  ---  |
|       |
|       |
|       |

Candidato(i) {

  Bool: Intervista_fatta = False

  while(!Intervista_fatta):

    // Accedo in mutua esclusione
    lock(CS) P2
    if (In_attesa <= N) {

      In_attesa++;
      unlock(CS)

      // Notifico l'arrivo di un candidato
      signal(Candidato)
      
      // Aspetto che vengo chiamato al tavolo 
      wait(Tavolo)

      // Fai interview 
      fai_intervista()
      Intervista_fatta = True

      // Segnalo che l'interview e` finita
      signal(Interview_finita)
      
      // Segnala posto disponibile
      signal(posto_disponibile)

      // Decremento in attesa 
      lock(CS)
      In_attesa--
      unlock(CS) 
    
    } else {
    
      unlock(CS)
      wait(posto_disponibile)
      
    }

  // Esci

}


|       |
|       |
|       |
|       |
|  ---  |

Addetto() {

  Bool candidati_finiti = False

  while(!candidati_finiti)

    // Aspetto che ci sia un candidato 
    wait(Candidato)

    // Comunica al candidato che e` disponibile a fare l'interview
    signal(Tavolo)

    // Aspetta che l'interview sia finita 
    wait(Interview_finita)
    
    // Se non ci sono piu` candidati
    lock(CS)
    if in attesa == 0 and Candidati_Creati == 0:
      candidati_finiti = True
    unlock(CS)


}

--------------------------------------------------------------

2 - AEROPORTO
Si consideri il seguente problema:
I passeggeri in transito in un aeroporto prima di imbarcarsi sull'aereo, devono superare i controlli di sicurezza.
I controlli sono gestiti come segue:
  Ogni passeggero sceglie tra N code quella più breve cui accodarsi ed attendere il proprio turno per passare il controllo.
  Ogni coda è gestita da un addetto che lascia passare il primo passeggero della coda,
indirizzandolo verso una delle M code di accesso al metal detector.
Ogni addetto indirizza il passeggero verso la coda più breve con lunghezza minore di K. 
Se il numero di code con lunghezza minore di K è inferiore a M/2, gli addetti non lasciano passare i passeggeri finchè persiste tale condizione.
Dopo aver attraversato il metal detector, il passeggero si dirige all'imbarco.


Const Int: Lunghezza_Min_Metal_Detector = K
Semaforo Contatore: Passeggeri = 0
Array di Interi: Indirizzamento_Passegeri[J] = {-1}
Array di SemB: Metal_Detector[M]
Array di Queue: Code_MD[N] = {0}
Array di SemB: Code_Bin[N] = 0;
Array di Queue: Code_Val[N] = {0}
Mutex: CS

Main() {

  for i=0 to J: 
    crea_processo(Passeggero, i)

  for i=0 to N: 
    crea_processo(Addetto, i)


}

Passeggero(i) {

  // Segnalo che c`e` un passeggero 

  // Controllo quale sia la coda piu breve e mi prendo l'indice a cui sta 

  // Faccio la wait sull'array di SemB a quell'indice e aspetto il controllo

  // Notificare all'addetto la mia i

  // Aspetto che l'addetto abbia capito quale sia la coda piu breve < K

  // Aspetto al Metal_Detector con l'indice contenuto in Indirizzamento_Passegeri[i]

  // Controllo MD();

  // Segnalo che sono passato al MD al mio indice

  // Vai ad imbarcarti
  
}



Addeto(i) {

  repeat

    // Aspetto che ci sia un passegero 
    
    // Segnalo alla mia posizione assegnata della coda che si puo passare 
    signal(code_bin[i])    

    // Aspetto la i di un passegero 

    // Controllo quale sia la coda piu breve con lunghezza < K e prendo l'indice
    // Ma se le code con lung. inferiore a K sono < M/2 ALLORA aspetto che si svuotino 
    // E poi segnalo che si puo passare al MD 

    // Comunico che ho scoperto l'indice e messo nell'array 

  forever

}
