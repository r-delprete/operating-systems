Un sistema è composto di un buffer di N posizioni, 2*N processi attivi ed un processo coordinatore. 
Il processo coordinatore estrae uno dopo l'altro in maniera casuale i numeri da 1 a N e ad ogni estrazione i 
processi competono per aggiudicarsi l'accesso alla posizione corrispondente del buffer, scrivendone il proprio PID. 
Un processo cha ha scritto il proprio PID nel buffer non partecipa più alla contesa. Quando tutte le posizioni del buffer 
sono state assegnate, il coordinatore si alterna con l’ultimo processo che ha avuto accesso al buffer nel leggere e stampare, 
uno alla volta, il contenuto del buffer.

Const N
Buffer[N] = {0}
indice = -1;
indice_stampa = 0
In_attesa = 0

Finiti = 0
Mutex CS = 1
Var. Condizione: Sveglia_processi
Semaforo Binario: Sveglia_Coordinatore = 0
Semaforo Binario: turno_coordinatore = 0
Semaforo Binario: turno_processo = 1

Main 

    crea_processo(coordinatore)

    for i = 0 to 2*N 
        crea_processo(competitore)
    endfor

    aspetta_processi()

Coordinatore 

    Repeat 
        
        // Estraggo num casuali da 1 a n, poi aspetto che tutti i procesi 
        // si siano messi in coda per svegliarli con una signal broadcast.
        indice = estrai_indice(1,N)
        
        // Aspetto che mi sveglino (ultimo processo)
        wait(Sveglia_Coordinatore)

        // Resetto in attesa (non in mutua esclusione, tutti i processi
        // competitore stanno dormendo asepttando me) 
        In_attesa = 0

        // Signal a tutti
        signal_broadcast(Sveglia_processi)

        // Se tutti i processi sono finiti, allora mi alterno con l'ultimo  
        // per stampare
        If (finiti = 2*N):
            for i = 0 to N:
                wait(turno_coordinatore)
                print([Buffer[Indice_stampa]])
                signal(turno_processo)
        endif

    Forever


Competitore 

    // Se non ho scritto nel buffer, sto nel loop
    scritto = false
    
    // Finche non ho scritto 
    while (!scrito):

        // Blocco il mutex e se sono l'ultimo processo in attesa, 
        // sblocco il coordinatore 
        // Inoltre la condizione si basa anche sui processi finiti
        lock(mutex)
        if(++In_attesa >= (2*N-finiti))

            // sblocco il cordinatore
            signal(Sveglia_Coordinatore)
        
        endif
        unlock(mutex)

        // Aspetto la signal broadcast del coordinatore
        wait(Sveglia_processi)

        // Mi prendo il mutex e scrivo nel buffer; 
        lock(mutex)

        // Controllo se l'indice sia N (tutti i posti sono stati scritti). IN tal caso, 
        // imposto solo scritto a true e aumento finiti, cosi esco 
        if (totale_scritti == N)
            scritto = True
            finiti ++
        endif
    
        else
            
            // Controllo il caso; se il buffer alla pos != 0, 
            // gia qualcuno ha scritto sopra, passo
            if (buffer[indice] != 0)
                pass
            else: 

                // Se sto nell'else, posso ancora scrivere. 
                // Scrivo e incremento i processi finiti
                scritto = True
                finiti ++

                // ALtrimenti uguale a 0: nessuno ha ancora scritto, 
                // ci scrivo sopra e incremento totale_scritti
                buffer[indice] = pid()
                totale_scritti++
            endif 

        unlock(mutex)

    endwhile

    // Se ho finito, controllo se sono l'ultimo per alternarmi la stampa col coordinatore 
    if (finiti == 2*N)

        for i = 0 to N:
            // Ho impostato turno_processo a 1, cosi l'ultimo processoo stampa per primo
            // e poi passa la palla al coordinatore. Non serve la mutua  esclusione perche 
            // sono sincronizzati a farlo uno alla volta
            wait(turno_processo)
            stampa(buffer[Indice_stampa])
            signal(turno_processo)
        endfor