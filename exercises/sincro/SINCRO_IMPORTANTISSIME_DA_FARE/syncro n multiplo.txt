/*
   Si consideri il seguente problema:
   
   In un sistema sono attivi N (N multiplo di 3) processi che si autorganizzano in tre gruppi seguendo il seguente
   schema. Inizialmente tutti competono per entrare nel gruppo G1 ma solo N/3 vi accedono. I restanti processi
   competono per entrare nel gruppo G2 ma solo N/3 vi accedono. I restanti N/3 processi sono assegnati al gruppo
   G3. Creati i gruppi, i processi appartenenti al gruppo G1, a turno ed all'infinito, scelgono un gruppo random G
   (G2 o G3), un numero random P in [0, N/3-1] e producono un elemento che verrà consumato dal processo P
  appartenente al gruppo G.
  
  Discutere la soluzione proposta in termini di possibili situazioni di starvation/deadlock e, nel caso, si propongano
  soluzioni ammissibili.
*/


//CI SONO VARI PROBLEMI DI STARVATION PER QUANTO RIGUARDA LA SECONDA PARTE DEL CODICE PER VIA DELLA SCELTA RANDOM DEL GRUPPO E DELL'INDICE POICHÈ POTREBBE NON ESSERE MAI SORTEGGIATO UN PROCESSO IN UNO DEI DUE GRUPPI


funzioni:
   controlla_gruppo(G)       //PASSATO UN GRUPPO , CONTROLLA SE I POSTI SONO TUTTI OCCCUPATI (tutti = 1) E RESITITUISCE 1 O 0 SE SONO ANCORA LIBERI
   Inserisci_Processo(pid,G) //INSERISCE UN PROCESSO NEL GRUPPO PASSATO DA INPUT
   Pieni(G1,G2,G3)           //CONTROLLA IN MUTUA ESCLUSIONE SE AD UNO AD UNO TUTTI I GRUPPI SONO STATI RIEMPITI
   produci(G)                //PRODUCE UN ELEMENTO 
   
   Sceglie_gruppo_rand(G2,G3) //SCEGLIE UN GRUPPO CON IL QUALE COMPETERE E LO RESITITUISCE IN OUTPUT


//ASSEGNAZIONE GRUPPI
mutex:semaforo_binario(:=1)


//PRODUTTORI
integer P
produci:semaforo_binario(:=0)


//CONSUMATORI
consuma:semaforo_binario(:=0)



conta = 0;

AssegnaProcesso()
begin

   //VIENE PRIMA EFFETTUATO UN INCREMENTO DI INDICE IN MUTUA ESCLUSIONE COSÌ CHE OGNI PROCESSO ABBIA IL PROPRIO INDICE,QUINDI NON SARANNO NECESSARI ALTRI MUTEX  
   wait(mutex)
   conta++;
   signal(mutex)
   
   if(conta < N/3){
		G1[conta] = pid
   }else if( conta < 2N/3 ){
		G2[conta] = pid
   }else if(conta < N){
		G3[conta] = pid
   }else{
		signal(produci) //Solo un processo farà la signal
   }
			
end


Produttori_G1(){  
begin
   repeat
   	  
     wait(produci)
   
     G=Sceglie_gruppo_rand(G2,G3)
      
     P=rand(0, N/3-1)

     produci(G[P])
     
     signal(consuma)
      
   forever
end
}


Consumatore_G(){
begin
   repeat
      wait(consuma)
      
      consuma(G[P])
      
      signal(produci)
   forever
end
}
